{"pages":[],"posts":[{"title":"Android Bluetooth整理","text":"一篇关于Android的蓝牙知识介绍，我是一个搬运工。 1. 蓝牙概述1.1 历史发展蓝牙为一种无线技术标准，蓝牙技术最初由爱立信创制。技术始于爱立信公司的1994方案，它是研究在移动电话和其他配件间进行低功耗、低成本无线通信连接的方法。这项无线技术的名称取自古代丹麦维京国王Harald Blåtand的名字，他以统一了因宗教战争和领土争议而分裂的挪威与丹麦而闻名于世，而这个名字的英文便是Harald Bluetooth。 蓝牙版本 发布时间 最大传输速度 传输距离 1.0 1998 723.1 Kbit/s 10米 1.1 2002 810 Kbit/s 10米 1.2 2003 1 Mbit/s 10米 2.0+EDR 2004 2.1 Mbit/s 10米 2.1+EDR 2007 3 Mbit/s 10米 3.0+HS 2009 24 Mbit/s 10米 4.0 2010 24 Mbit/s 50米 4.1 2013 24 Mbit/s 50米 4.2 2014 24 Mbit/s 50米 5.0 2016 48 Mbit/s 300米 5.1 2019 48 Mbit/s 300米 1998年蓝牙1.0发布，2.1版本使用最广，即经典蓝牙，很多非智能设备也支持这个版本。到了蓝牙3.0就是所谓的高速蓝牙。4.0以前为传统蓝牙，主要以BR(基础率)/EDR(增强数据率)为发展技术，以点对点网络拓扑结果创建一对一设备通信。4.0/4.1及以后引入LE规范，即低功耗蓝牙，LE型蓝牙使用点对点（一对一）、广播（一对多）和网格（多对多）等多种网络拓扑结构。实际使用中分为单模和双模版本，前者支持LE规范且不能喝蓝牙4.0之前的版本通信，后者同时支持LE和BR/EDR规范，并且兼容旧版蓝牙。5.0 版本支持室内定位导航功能(结合WiFi时线高精度室内定位)，针对物联网进行了很多底层优化。 1.2 应用 手机 设备间无线通讯 电脑与外设 鼠标、键盘、耳机、打印机等 汽车 车载娱乐系统、监测和诊断机电系统等 消费类电子产品 电视、游戏机、游戏手柄等 医疗 心率监视器、血糖监测仪等 可穿戴设备 智能眼镜、耳机、运动相机等 智能家居 位置导向式服务 无线信号以确定物品位置 1.3 协议栈蓝牙协议栈主要由主机(Host)、控制器(Controller)、主机控制器接口(HCI)三部分组成。 1.3.1 HostHost层是对硬件的抽象，像PC端就可以理解为Host，但Host与具体的硬件无关。Host包含逻辑链路控制和适配层(Logical Link control &amp; Adaption Protocol, L2CAP)、通道管理器（Channel Manager）、安全管理协议(SMP)和GAP等其他高层协议。L2CAP主要起到数据缓冲和简单数据管理的作用，通道管理器负责创建，管理和关闭用于传输服务协议和应用程序数据流的L2CAP通道。Profile 就是定义了一个实际的应用场景。具体来说，Profile 定义了蓝牙系统中从PHY（物理层）到 L2CAP 的每层以及核心规范之外的任何其他协议所需的功能和特性。应用的行为和数据格式也由 Profile 定义。其中比较常用的配置文件就是GAP，即通用访问配置文件，所有蓝牙设备都必须实现的基本配置文件。 BR/EDR型蓝牙中GAP定义每个设备为单一角色，其可能具备的功能包括设备如何相互发现，建立连接以及描述用于身份验证的安全关联模型。设备可能只具备其中一种或多种功能，比如只具有启动或接受连接功能。 LE型蓝牙中GAP 定义了四个特定角色：Broadcaster，Observer，Peripheral 和 Central。如果底层 Controller 支持这些角色或角色组合，则设备也可同时支持多个角色。但是，在某一时刻只能支持其中一个角色。每个角色都指定了底层Controller的要求。这允许控制器针对特定用例进行优化。 RFCOMM 是一种简单的传输协议，其实也是用于仿真RS-232串口通信。RFCOMM支持在两个设备之间模拟多个串口，或者在多个设备之间模拟串口，最多支持 两个设备间 60 个串口的同时连接。SPP 可以视为仅是对 RFCOMM的简单封装。A2DP高级音频分发配置文件，实现单声道或立体声高质量音频内容分配的协议和程序。典型的使用情况是将音乐内容从立体声音乐播放器流式传输到耳机或扬声器。 1.3.2 ControllerControllers可对应现实生活中的蓝牙芯片或者蓝牙适配器，是协议栈的底层实现，与硬件直接相关。主控制器可以是以下三种： BR/EDR控制器（单模） LE控制器(单模) BR/EDR和LE组合控制器(双模) 可选的还有一个或多个次要控制器(AMP)，AMP在蓝牙3.0后就引入了，主要和BR/EDR搭配使用，作为数据高速传输通道。实际上还可以排列组合出其他几种单模或双模的控制器架构。 1.3.3 HCIHCI(主机控制器接口)它为基带控制器、连接管理器、硬件状态和控制寄存器提供命令接口。HCI层是可选的，在具有简单功能的蓝牙设备(如耳机)中，Host和控制器可以在同一微处理器上实现，而无需HCI。 2. 传统蓝牙传统蓝牙或称经典蓝牙即蓝牙4.0版本之前，主要以BR/EDR为发展技术，以点对点网络拓扑结果创建一对一设备通信。 2.1 概述Android平台提供对蓝牙的通讯栈的支持，允许设备与其他设备进行无线传输数据。传统蓝牙适用于较为耗电的操作，其中包括 Android 设备之间的流式传输和通信等。应用层可通过Bluetooth API进行以下操作： 扫描其他蓝牙设备 查询本地蓝牙适配器的配对蓝牙设备 建立 RFCOMM 通道 通过服务发现连接到其他设备 与其他设备进行双向数据传输 管理多个连接 2.3 传统蓝牙 Android应用开发2.3.1 权限使用蓝牙功能前必须在应用清单中声明以下权限: 123456789&lt;manifest ...&gt; &lt;!-- 需要此权限才能执行任何蓝牙通信，例如请求连接、接受连接和传输数据等 --&gt; &lt;uses-permission android:name=\"android.permission.BLUETOOTH\" /&gt; &lt;!-- 如果您想让应用启动设备发现或操纵蓝牙设置，则除了 BLUETOOTH 权限以外，您还必须声明 BLUETOOTH_ADMIN 权限。 --&gt; &lt;uses-permission android:name=\"android.permission.BLUETOOTH_ADMIN\" /&gt; &lt;!-- 应用需要此权限，因为蓝牙扫描可用于收集用户的位置信息。 --&gt; &lt;!-- Android 9及以下的版本中声明为 ACCESS_COARSE_LOCATION --&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" /&gt;&lt;/manifest&gt; 2.3.2 BluetoothAdapter所有蓝牙应用都需要蓝牙适配器（BluetoothAdapter），可通过静态方法getDefaultAdapter() 来获取适配器的实例对象，一个蓝牙设备只有一个蓝牙适配器。示例代码如下： 123456private BluetoothAdapter bluetoothAdapter;...// 初始化 蓝牙适配器final BluetoothManager bluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);bluetoothAdapter = bluetoothManager.getAdapter(); BluetoothAdapter提供诸多方法来进行蓝牙操作，如调用 isEnabled() 检查当前是否已启用蓝牙。调用 enable() 开启蓝牙的方法已被弃用，现在的请求启用蓝牙做法如下： 12Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT); 该操作将显示对话框，请求用户允许启用蓝牙，用户的响应可在onActivityResult()得到。其他的广播Intent字段还有ACTION_STATE_CHANGED，当蓝牙状态发送改变，系统会广播此Intent，通过该Intent的额外字段来获取蓝牙的状态。利用BluetoothAdapter可通过设备来查找远程蓝牙设备。这是一个扫描过程，开启扫描后设备会搜索局部内已启用蓝牙功能的其他设备，并请求与每台设备相关的某些信息，只有在当下接受信息请求时，附近区域的蓝牙设备才会通过启用可检测性响应发现请求。如果设备已启用可检测性，它会通过共享一些信息（例如设备的名称、类及其唯一的 MAC 地址）来响应发现请求。借助此类信息，执行发现过程的设备可选择发起对已检测到设备的连接。在首次与远程设备建立连接后，系统会自动向用户显示配对请求。当设备完成配对后，系统会保存关于该设备的基本信息（例如设备的名称、类和 MAC 地址），并且可使用 Bluetooth API 读取这些信息。借助远程设备的已知 MAC 地址，您可以随时向其发起连接，而无需执行发现操作（假定该设备仍处于有效范围内）。其中配对是指两台设备知晓彼此的存在，共享链路密钥，能够建立加密连接。而连接是指设备当前共享一个 RFCOMM 通道，并且能够向彼此传输数据。即配对是连接的前提。 启用可检测性Android设备默认处于不可被检测的状态，用户可以通过系统设置来将设备设置为在有限时间处于可被检测状态，开发者也能够请求用户启用可检测性。具体做法如下： 123Intent discoverableIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);discoverableIntent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 10);startActivityForResult(discoverableIntent,REQUEST_DISCOVERABLE); 如果您希望将本地设备设为可被其他设备检测到，请使用 ACTION_REQUEST_DISCOVERABLE 操作 Intent 调用 startActivityForResult(Intent, int)。这将通过系统设置发出启用可检测到模式的请求（无需停止您的应用）。默认情况下，设备将变为可检测到并持续 120 秒钟。您可以通过添加EXTRA_DISCOVERABLE_DURATION Intent Extra 来定义不同的持续时间。应用可以设置的最大持续时间为 3600 秒，值为 0 则表示设备始终可检测到。 任何小于 0 或大于 3600 的值都会自动设为 120 秒。 发现设备要开始发现设备，只需调用startDiscovery()，该方法为异步，且会返回一个布尔值，表示是否已成功启动发现操作。应用必须针对ACTION_FOUND Intent注册一个BroadcastReceiver，以便接受每台发现的设备信息。Intent 将携带额外字段 EXTRA_DEVICE 和 EXTRA_CLASS，二者分别包含 BluetoothDevice 和 BluetoothClass。注意：执行设备发现对于蓝牙适配器而言是一个非常繁重的操作过程，并且会消耗大量资源。在找到要连接的设备后，确保始终使用cancelDiscovery() 停止发现，然后再尝试连接。不应该在处于连接状态时执行发现操作。 2.3.3 BluetoothDevice该类代表一个远程蓝牙设备，使用这个来请求一个与远程设备的BluetoothSocket连接，或者查询关于设备名称、地址、类和连接状态等设备信息。我们可以通过获取到的适配器来创建蓝牙设备，若已知MAC地址可通过以下方法来创建： 1BluetoothDevice device = bluetoothAdapter.getRemoteDevice(MAC); 2.3.4 设备连接在两台设备之间建立连接，需要有一台设备作为服务器端，保持开放的服务器套接字来侦听传入的连接请求，即BluetoothServerSocket。另一台作为客户端，使用服务端的MAC地址发起连接。在打开与服务器相连的 RFCOMM 通道时，客户端会提供套接字信息，即从BluetoothServerSocket获取BluetoothSocket。当服务器和客户端在同一 RFCOMM 通道上分别拥有已连接的 BluetoothSocket 时，即可将二者视为彼此连接。 BluetoothSocket(客户端)在客户端上，BluetoothSocket代表一个蓝牙socket的接口（和TCP Socket类似）。这是一个连接点，它允许一个应用与其他蓝牙设备通过InputStream和OutputStream交换数据。最常用的蓝牙socket就是Android API所支持的RFCOMM，它是一个为蓝牙提供定向连接、数据流传输的通道。我们可以通过BluetoothDevice类的方法createRfcommSocketToServiceRecord(UUID)来创建一个BluetoothSocket，然后调用connect()连接远程设备。连接后通过getInputStream()和getOutputStream()来打开IO数据流准备进行数据交互。当不使用socket的时候应该调用close()来关闭通道。建立连接的示例代码如下： 12345678910111213141516public void connect(BluetoothDevice device){ bluetoothSocket = device.createInsecureRfcommSocketToServiceRecord(MY_UUID); try { //建立RFCOMM Socket通道 bluetoothSocket = device.createInsecureRfcommSocketToServiceRecord(MY_UUID); if (!bluetoothSocket.isConnected()){ bluetoothAdapter.cancelDiscovery(); bluetoothSocket.connect(); inputStream = bluetoothSocket.getInputStream(); outputStream = bluetoothSocket.getOutputStream(); } }catch (IOException e){ bluetoothSocket.close(); e.printStackTrace(); }} 使用 BluetoothDevice，通过调用 createRfcommSocketToServiceRecord(UUID) 获取 BluetoothSocket。（这里的UUID必须与服务端的保持一致）通过调用 connect() 发起连接。注：在调用 connect() 时，应始终确保设备未在执行设备发现。 如果正在进行发现操作，则会大幅降低连接尝试的速度，并增加连接失败的可能性。因此，在进行连接之前必须调用cancelDiscovery()来关闭查找设备。 BluetoothServerSocket(服务器端)在服务器端，BluetoothServerSocket代表一个开放的服务端socket，它监听接受的请求（与TCP ServerSocket类似）。为了连接两台Android设备，一个设备必须使用这个类开启一个服务器socket。当一个远程蓝牙设备开始一个和该设备的连接请求，BluetoothServerSocket将会返回一个已连接的BluetoothSocket，接受该连接。建立连接的示例代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private class AcceptThread extends Thread { private final BluetoothServerSocket mmServerSocket; public AcceptThread() { BluetoothServerSocket tmp = null; try { tmp = mAdapter.listenUsingRfcommWithServiceRecord(NAME,MY_UUID); } catch (IOException e) { e.printStackTrace(); } mmServerSocket = tmp; mState = STATE_LISTEN; } public void run() { BluetoothSocket socket = null; while (mState != STATE_CONNECTED) { try { socket = mmServerSocket.accept(); } catch (IOException e) { break; } if (socket != null) { synchronized (BluetoothService.this) { switch (mState) { case STATE_LISTEN: case STATE_CONNECTING: connected(socket, socket.getRemoteDevice()); break; case STATE_NONE: case STATE_CONNECTED: try { socket.close(); } catch (IOException e) { e.printStackTrace(); } break; } } } } } public void cancel() { try { mmServerSocket.close(); } catch (IOException e) { } } } 通过调用 listenUsingRfcommWithServiceRecord(String, UUID) 获取 BluetoothServerSocket。 通过调用 accept() 开始侦听连接请求。 如果不想让更多的设备连接，则在连接后调用close()关闭。 注意：MY_UUID必须与客服端连接时的UUID一致。调用accept()方法是一个阻塞调用，需要新开一个线程。 2.3.5 传输数据在配对结束后可以进行通信及数据的传输了。首先我们要通过得到的BluetoothSocket来获取InputStream和OutputStream。 写数据1234567public void write(byte[] data){ try{ outputStream.write(data); }catch(IOException e){ e.printStackTrace(); }} 读数据123456789byte[] buffer = new byte[1024];int bytes;while(mState == STATE_CONNECTED){ try{ bytes = inputStream.read(buffer); }catch(IOException e){ e.printStackTrace(); }} 3.BLEBLE即低功耗蓝牙(Bluetooth Low Energy)，在蓝牙4.0版本后引入，LE型蓝牙使用点对点（一对一）、广播（一对多）和网格（多对多）等多种网络拓扑结构。Android在4.3后开始引入BLE相关的API，使得应用程序能够通过这一套API扫描蓝牙设备、查询服务、读写设备属性等操作。与传统蓝牙不同的是，BLE旨在提供显著降低的功耗，这使 Android 应用可与功率要求更严格的 BLE 设备（例如近程传感器、心率监测仪和健身设备）通信。 3.1 BLE相关概念 GATT 通用属性配置文件：GATT 配置文件是一种通用规范，内容针对在 BLE 链路上发送和接收称为“属性”的简短数据片段。 ATT 属性协议：ATT是GATT的构建基础 实际上GATT和ATT也可用于BR/EDR，LE型蓝牙需要它来搜寻服务，因此必不可少。GATT定义了三个概念： Service 服务：服务是一系列特征。例如，您可能拥有名为“心率监测器”的服务，其中包括“心率测量”等特征。一个蓝牙设备可以定义许多Service，Service可理解为一个功能的集合，每个Service都有一个128位的UUID作为标志。蓝牙技术联盟定义UUID公用一个基本UUID：0x0000xxxx-0000-1000-8000-00805F9B34FB。为了进一步简化，还有一种定义是每个属性有一个唯一的16位ID，即代替基本UUID的“x”部分。 Characteristic 特征：Service以下又包括了各个独立数据项，这些数据项称为Characteristic，每个数据项也有一个唯一的UUID标识符。特征包含一个值和 0 至多个描述特征值的描述符。我们说的通过蓝牙发送数据给外围设备就是往这些 Characteristic 中的 Value 字段写入数据；外围设备发送数据给手机就是监听这些 Charateristic 中的 Value 字段有没有变化，如果发生了变化，手机的 BLE API 就会收到一个监听的回调。 Descriptor描述符是描述特征值的已定义属性。例如，描述符可指定人类可读的描述、特征值的可接受范围或特定于特征值的度量单位。 总结： 一个 Service 包含若干个 Characteristic，一个 Characteristic 包含若干 Descriptor。Characteristic 定义了数值和操作。把若干个相关的 Service 组合在一起，就成为了一个 Profile。 3.3 Android上的BLE在使用该功能时先声明相关权限，与传统蓝牙一样，需要借助BluetoothAdapter，这里不再累述。将BluetoothDevice取而代之的是BluetoothGatt，即设备的Gatt服务，面向服务编程。 BLE设备扫描 API 21以前扫描操作由BluetoothAdapter类提供实现方法。 12public boolean startLeScan(BluetoothAdapter.LeScanCallback callback);public boolean startLeScan(UUID[] serviceUuids, BluetoothAdapter.LeScanCallback callback); 以上方法需传入蓝牙适配器类所提供的回调对象()，也可以指定扫描设备的UUID。回调接口如下： 123456789101112public interface LeScanCallback { /** * Callback reporting an LE device found during a device scan initiated * by the {@link BluetoothAdapter#startLeScan} function. * @param device Identifies the remote device * @param rssi The RSSI value for the remote device as reported by the * Bluetooth hardware. 0 if no RSSI value is available. * @param scanRecord The content of the advertisement record offered by * the remote device. */ public void onLeScan(BluetoothDevice device, int rssi, byte[] scanRecord);} API 21以后在API 21及以上，官方弃用了BluetoothAdapter的startLeScan和stopLeScan。而是新引入了BluetoothLeScanner类(被单独封装为一个新类)和ScanCallback回调接口。对应的BluetoothLeScanner对象由蓝牙适配器的方法 getBluetoothLeScanner() 获得。扫描接口如下： 12345678public final class BluetoothLeScanner{ public void startScan(ScanCallback callback); public void startScan(List&lt;ScanFilter&gt; filters, ScanSettings settings, ScanCallback callback); public int startScan(@Nullable List&lt;ScanFilter&gt; filters, @Nullable ScanSettings settings, @NonNull PendingIntent callbackIntent); public void stopScan(ScanCallback callback); public void stopScan(PendingIntent callbackIntent); ...} 若开始扫描操作后而没有传入过滤条件，扫描动作将在设备屏幕关闭后停止以节省能源，若设备屏幕唤醒则继续进行扫描，毕竟扫描操作是一个较耗电的过程。ScanFilter可限制扫描结果为我们只关心的结果，过滤条件包括服务的UUID、远程设备名称、远程设备的Mac地址等。ScanSettings则是扫描参数设置，例如设置扫描动作是以节能为优还是以效率为优，相比原来的API有了更加细化的操作。扫描回调接口如下： 12345public abstract class ScanCallback { public void onScanResult(int callbackType,ScanResult result); public void onBatchScanResults(List&lt;ScanResult&gt; results); public void onScanFailed(int errorCode);} ScanResult是对扫描结果的封装，可通过getDevice()来获取远程设备对象。 连接BLE设备的GATT服务要在BLE设备上连接到GATT服务可使用由BluetoothDevice类提供的实现方法： 123public BluetoothGatt connectGatt(Context context, boolean autoConnect, BluetoothGattCallback callback); 其中第二个参数表示是否在BLE设备可用时自动连接到该设备。连接到由BLE设备托管的GATT服务后，返回一个BluetoothGatt实例，由这个实例就能够执行客户端操作。其中GATT变化时通过BluetoothGattCallback类回调，第三个参数为Gatt服务回调的引用，需要自行实现该抽象类。 GATT服务回调BluetoothGattCallback类提供的接口如下： 1234567public abstract class BluetoothGattCallback{ public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState); public void onServicesDiscovered(BluetoothGatt gatt, int status); public void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic); public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status); public void onCharacteristicWrite(BluetoothGatt gatt,BluetoothGattCharacteristic characteristic,int status);} onConnectionStateChange当连接状态发生改变时将调用此接口，newstate即为当前服务的连接状态，可在此方法实现自己的业务逻辑，例如发送自定义广播来监听此事件。 onServicesDiscovered发现设备服务时回调此接口，status为该服务的订阅状态，若订阅成功需要在此方法处理订阅事件。我们可获取BLE设备的所有GATT服务，而后获取每个服务的特征特性，并保存下来。若是需要与某个特定服务中的特定属性进行数据读写则需要筛选服务的UUID和特征的UUID。在找到想要订阅的特性后，我们希望它在改变时能够得到通知，则需要调用BluetoothGatt提供的方法： 1public boolean setCharacteristicNotification(BluetoothGattCharacteristic characteristic, boolean enable); 开启通知后才能在以下接口产生回调，即订阅了该服务特征。 onCharacteristicChanged监听GATT服务及服务特性的数据变化(即接受到消息时回调)。 onCharacteristicRead在读取特征属性时结果回调在此接口，读取特征属性调用BluetoothGatt类所提供的方法： 1public boolean readCharacteristic(BluetoothGattCharacteristic characteristic); onCharacteristicWrite在向BLE设备发送数据时回调在此接口，发送数据调用BluetoothGatt类所提供的方法： 1public boolean writeCharacteristic(BluetoothGattCharacteristic characteristic); 更详细的信息移步Android开发者官网","link":"/2019/12/23/Android%20Bluetooth%E6%95%B4%E7%90%86/"},{"title":"Netty入门之打造一个简易的RPC框架","text":"第一次用Netty来做C\\S项目的入门实操。 1. 基础部分1.1 连接1234567891011121314//ClientService connect()EventLoopGroup group = new NioEventLoopGroup();Bootstrap bootstrap = new Bootstrap();bootstrap.channel(NioSocketChannel.class) .group(group) .option(ChannelOption.CONNECT_TIMEOUT_MILLIS,connectTimeOut) .option(ChannelOption.TCP_NODELAY, true) .option(ChannelOption.SO_KEEPALIVE, true) .handler(new LoggingHandler(LogLevel.INFO)) .handler(initializer);ChannelFuture future = bootstrap.connect(ClientApplication.getHost(), getPort());channel = future.sync().channel();//同步阻塞channel.closeFuture().sync(); 数据实体 Request请求实体：12345678910111213141516171819public class Request implements Serializable { //请求ID private String id; //数据类型 private int type; //服务名 private String serviceName; //方法名称 private String methodName; // 参数列表 private Object[] parameters; //参数类型 private Class&lt;?&gt;[] parameterTypes;} 请求实体包括: ID，每个请求都有一个唯一的ID作为标识，用于识别与之对应的响应实体，关于ID生成以下会涉及到； 类型，自定义的类型字段，标明业务类型，whatever… 服务名，其实就是对应接口(远程方法)所在的类； 方法名，对应的接口名； 参数列表，对应接口的参数列表； 参数类型，参数列表对应的参数类型表。 Response响应实体： 12345678910111213public class Response implements Serializable { //对应的请求ID private String requestId; //响应代码 private int code; //错误信息 private String message; //数据实体 private Object data;} 响应实体包括： 响应的请求ID； 响应代码，标识成功或失败等作用； 错误信息，远程端在执行方法时可以通过抛出异常并写入这个字段来响应到客户端； 数据实体，即远程方法的返回值。 方法代理的实现12345678910111213141516171819202122232425262728293031323334//方法代理实现public class ServiceProxyFactory implements InvocationHandler { private ClientService client; private String serviceName; public ServiceProxyFactory(ClientService client, String name){ this.client = client; this.serviceName = name; } public Object create(Object service) { return Proxy.newProxyInstance( service.getClass().getClassLoader(), service.getClass().getInterfaces(), this); } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Request request = new Request(); //设置服务名 request.setServiceName(this.serviceName); //设置方法名 request.setMethodName(method.getName()); //设置参数列表 request.setParameters(args); //设置参数类型 request.setParameterTypes(method.getParameterTypes()); //设置请求ID request.setId(Id.getId()); request.setType(MsgType.TYPE_WORK); //发送请求 Response response = client.send(request, ClientApplication.getTimeOut()); //远程方法返回类型 Class&lt;?&gt; returnType = method.getReturnType(); //其他业务逻辑 省略... }} 发送请求12345678910111213//ClientService public Response send(Request request) throws InterruptedException { if (channel != null &amp;&amp; channel.isActive()) { LinkedBlockingDeque&lt;Response&gt; queue = handler.sendRequest(request, channel); //从远程服务器拿结果 阻塞线程 return queue.take(); } else { Response res = new Response(); res.setCode(MsgType.STATUS_FAILED); res.setMessage(\"未正确连接到服务器,请检查相关配置信息!\"); return res; }} 在ClientHandler编写接收响应和发送请求的业务逻辑: 1234567891011121314151617181920//ClientHandlerpublic class ClientHandler extends SimpleChannelInboundHandler&lt;Response&gt;{ private ConcurrentHashMap&lt;String,LinkedBlockingDeque&lt;Response&gt;&gt; queueMap = new ConcurrentHashMap&lt;&gt;(); @Override public void onReceive(ChannelHandlerContext ctx, Response response) throws Exception{ String requestId = response.getRequestId(); LinkedBlockingDeque&lt;Response&gt; queue = queueMap.get(requestId); queue.put(response); queueMap.remove(requestId); } public LinkedBlockingDeque&lt;Response&gt; sendRequest(Request request, Channel channel) { String requestId = request.getId(); LinkedBlockingDeque&lt;Response&gt; deque = new LinkedBlockingDeque&lt;&gt;(); queueMap.put(requestId,deque); channel.writeAndFlush(request); return deque; }} 设置超时执行远程方法是一个阻塞的操作，如果服务端没有响应可能会让线程处于一直等待的状态，我们给它设定一个超时机制，如果超过规定时间还未返回结果则返回错误。 123456789101112131415161718192021222324252627282930313233343536/*** 发送请求* @param request 请求实体* @param timeOut 超时设置(ms)*/public Response send(Request request, long timeOut) { Response response = new Response(); final ExecutorService exec = Executors.newFixedThreadPool(1); Callable&lt;Response&gt; call = () -&gt; { try { return send(request); } catch (InterruptedException e) { e.printStackTrace(); } return null; }; try { Future&lt;Response&gt; future = exec.submit(call); //任务处理超时时间 if (timeOut&gt;0){ response = future.get(timeOut, TimeUnit.MILLISECONDS); }else { response = future.get(); } } catch (TimeoutException ex) { response.setRequestId(request.getId()); response.setCode(MsgType.STATUS_TIMEOUT); } catch (Exception e) { response.setRequestId(request.getId()); response.setMessage(e.getMessage()); response.setCode(MsgType.STATUS_FAILED); } // 关闭线程池 exec.shutdown(); return response;} Netty添加HTTPS支持 客户端 123456SslContext sslCtx = null;try { sslCtx = SslContext.newClientContext(InsecureTrustManagerFactory.INSTANCE);} catch (SSLException e) { ...} 在ChannelInitializer初始化连接时将SslHandler添加到ChannelPipline中： 1234567public class ClientChannelInitializer extends ChannelInitializer&lt;SocketChannel&gt; { @Override public void initChannel(Channel channel) throws Exception { channel.pipeline().addFirst(sslCtx.newHandler(channel.alloc())); ... }} 服务端 1234567SslContext sslCtx = null;try { SelfSignedCertificate cert = new SelfSignedCertificate(); sslCtx = SslContext.newServerContext(cert.certificate(),cert.privateKey());} catch (Exception e) { ...} 123456789public class ServerChannelInitializer extends ChannelInitializer&lt;SocketChannel&gt; { @Override protected final void initChannel(SocketChannel channel) throws Exception { SSLEngine engine = sslCtx.newEngine(channel.alloc()); engine.setUseClientMode(false); channel.pipeline().addFirst(new SslHandler(engine)); ... }} 以上代码为所有的通信启用了SSL/TLS 加密。","link":"/2019/12/28/Netty%E5%85%A5%E9%97%A8%E4%B9%8B%E6%89%93%E9%80%A0%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84RPC%E6%A1%86%E6%9E%B6/"},{"title":"Android JNI入门","text":"刚开始工作时接触了一些JNI，此篇文章记录我的入门历程。 开始 JNI 即Java Native Interface 从Java 1.1开始就成为了Java标准的一部分， JNI 是 Java 和 C/C++ 组件用以互相通信的接口。 此处了解 JNI原生接口规范 首先需要以下组件： Android 原生开发工具包,这套工具集允许您为 Android 使用 C 和 C++ 代码，并提供众多平台库，让您可以管理原生 Activity 和访问物理设备组件，例如传感器和触摸输入。 LLDB：一种调试程序，Android Studio 使用它来调试原生代码。 集成方法：1 ndk-build:ndk-build 脚本可用于编译采用 NDK 基于 Make 的编译系统的项目。 1.1 Android.mkAndroid.mk是Android提供的一种makefile文件， 用来指定诸如编译生成so库名、 引用的头文件目录、 需要编译的.c / .cpp文件和.a静态库文件等，创建在JNI目录下。详情见 Android.mk。 1.2 Application.mkApplication.mk 指定了 ndk-build 的项目范围设置。默认情况下，它位于应用项目jni目录中。详情见 Application.mk 2 CMake:Android Studio 2.2及以上，使用 NDK 和 CMake 将 C 及 C++ 代码编译到原生库中，Android Studio 会使用 IDE 的集成构建系统 Gradle 将您的库封装到 APK。一款外部构建工具，可与 Gradle 搭配使用来构建原生库。如果只计划使用ndk-build，则不需要此组件。详情见 CMake在Gradle中使用CMake变量： 1234567891011121314151617android { ... defaultConfig { ... externalNativeBuild { cmake { ... } } } buildTypes {...} externalNativeBuild { cmake { path \"CMakeLists.txt\" //CMake构建脚本的相对路径 } }} CMake 按照构建脚本中的命令将 C++ 指定的源文件编译到共享的对象库中，并命名为自定义的so库，Gradle随后会将其打包到APK中。 Java在本地方法类中使用System.loadLibrary(“libJniTest.so”)加载自己编写并编译好的原生库。 JNI注册本地方法JNI中的方法例如： Java_包名_类名_方法名 Java_com_kun_Tes_JniTest_FunctionA则在JniTest类中的方法映射为FunctionA()。也可通过如下方式来生成本地方法： 1. 命令生成通过命令javah生成java类对应的c头文件。设置流程：Android Studio - &gt; File - &gt; Settings - &gt; Tools - &gt; External Tools， 新增名为javah的工具。设置如下： 变量名 值 Program $JDKPath$\\ bin\\ javah.exe Arguments -d jni - classpath $ModuleFileDir$\\ src\\ main\\ Java $FileClass$ Working directory $ModuleFileDir$\\ src\\ main 2. 动态注册函数应用层在加载so文件时， 虚拟机会首先执行JNI_OnLoad方法。我们需要重载JNI_OnLoad方法： 12345678910111213141516JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM * vm, void * reserved) { //注册时在JNIEnv中实现的，所以必须首先获取它 JNIEnv * env = NULL; jint result = JNI_ERR; sVm = vm; //从JavaVM获取JNIEnv，一般使用1.4的版本 if (vm - &gt; GetEnv((void ** ) &amp; env, JNI_VERSION_1_4) != JNI_OK) //从JavaVM获取JNIEnv，一般使用1.4的版本 { return result; } //这里很重要，必须返回版本，否则加载会失败。 if (jniRegisterNativeMethods(env, JAVA_CLASS_NAME, method_table, NELEM(method_table)) == JNI_OK) { result = JNI_VERSION_1_4; } return result;} 在C/C++文件中需定义并实现对应Java中声明的本地方法， 方法名可以随意， 参数类型与参数个数要相同。 12345678910111213141516171819jint jniRegisterNativeMethods(JNIEnv * env, const char * className, const JNINativeMethod * gMethods, int numMethods) { LOGI(\"jni onload called\"); jclass clazz; clazz = env - &gt; FindClass(className); // 获取映射的java类 if (clazz == nullptr) { cout &lt;&lt; \"cannot get class: \" &lt;&lt; className &lt;&lt; endl; return -1; } if (env - &gt; RegisterNatives(clazz, gMethods, numMethods) &lt; 0) // 通过RegisterNatives方法动态注册 { cout &lt;&lt; \"register native method failed!\" &lt;&lt; endl; return -1; } LOGI(\"jni onload called end...\"); return 0;} JNI中回调Java方法有时候在执行jni方法时想要回调java方法，jni.h中有提供相关api来做这件事。例如Java中有一个方法： 123public int callback(int arg){ //...} JNI中的回调方式则为: 1234567891011121314void _jniCallback(JNIEnv *env,jobject obj){ //寻找对应的java本地方法类 jclass jSdkClass = (*env)-&gt;GetObjectClass(env,obj); if(jSdkClass==0) { //找不到类，异常处理... return; } //在java类中寻找一个名为\"callback\"的方法，第三个参数为方法名，第四个参数为方法的参数签名 jmethodID javaCallback = (*env)-&gt;GetMethodID(env, jSdkClass,\"callback\", \"(I)I\"); //进行回调 第三个参数及以后为方法的输入参数 jint ret = (*env)-&gt;CallIntMethod(env,obj,javaCallback,1);} 在jni中有多种方法来实现类似的回调，若方法为static修饰，则使用GetStaticMethodID及CallStaticIntMethod，其他类似回调大同小异，就暂不累述。","link":"/2019/06/17/Android%20JNI%E5%85%A5%E9%97%A8/"},{"title":"关于Java锁的整理(持续更新)","text":"Java中的锁问题很是头疼，于是我觉得是时候梳理一下了。 1. 锁分类1.1 公平锁/非公平锁公平锁是指多个线程按照申请锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该所，这种就是公平锁。非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。这样就可能导致某个或者一些线程永远获取不到锁。在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。而对于ReentrantLock和ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁。(以下会涉及) 1.2 可重入锁可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。synchronized和Lock都具备可重入性。可重入锁的一个好处是可一定程度避免死锁。例1 1234567891011public class Widget { // 锁住了 public synchronized void doSomething() { ... }} public class LoggingWidget extends Widget { // 锁住了 public synchronized void doSomething() { System.out.println(toString() + \": calling doSomething\"); super.doSomething(); } } 当线程A进入到LoggingWidget的doSomething()方法时，此时拿到了LoggingWidget实例对象的锁。随后在方法上又调用了父类Widget的doSomething()方法，它又是被synchronized修饰。那现在我们LoggingWidget实例对象的锁还没有释放，进入父类Widget的doSomething()方法还需要一把锁吗？不需要的！因为锁的持有者是“线程”，而不是“调用”。线程A已经是有了LoggingWidget实例对象的锁了，当再需要的时候可以继续“开锁”进去的！ 例2 1234567synchronized void setA() throws Exception{ Thread.sleep(1000); setB(); } synchronized void setB() throws Exception{ Thread.sleep(1000); } 上面的代码就是一个可重入锁的一个特点，如果不是可重入锁的话，setB可能不会被当前线程执行，可能造成死锁。 1.3 独享锁/共享锁独享锁是指该锁一次只能被一个线程所持有。共享锁是指该锁可被多个线程所持有。于Java ReentrantLock而言，其是独享锁。但是对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。对于Synchronized而言，当然是独享锁。 1.4 互斥锁/读写锁独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。互斥锁在Java中的具体实现就是ReentrantLock读写锁在Java中的具体实现就是ReadWriteLock 1.5 乐观锁/悲观锁乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。悲观锁在Java中的使用，就是利用各种锁。乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。 1.6 分段锁分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。 1.7 偏向锁/轻量级锁/重量级锁这三种锁是指锁的状态，并且是针对Synchronized。在Java 5通过引入锁升级的机制来实现高效Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。 1.8 自旋锁在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。自旋锁是采用让当前线程不停地的在循环体内执行实现的，当循环的条件被其他线程改变时 才能进入临界区。如下 123456789101112public class SpinLock { private AtomicReference&lt;Thread&gt; sign =new AtomicReference&lt;&gt;(); public void lock(){ Thread current = Thread.currentThread(); while(!sign .compareAndSet(null, current)){ } } public void unlock (){ Thread current = Thread.currentThread(); sign .compareAndSet(current, null); }} 使用了CAS原子操作，lock函数将owner设置为当前线程，并且预测原来的值为空。unlock函数将owner设置为null，并且预测值为当前线程。当有第二个线程调用lock操作时由于owner值不为空，导致循环一直被执行，直至第一个线程调用unlock函数将owner设置为null，第二个线程才能进入临界区。由于自旋锁只是将当前线程不停地执行循环体，不进行线程状态的改变，所以响应速度更快。但当线程数不停增加时，性能下降明显，因为每个线程都需要执行，占用CPU时间。如果线程竞争不激烈，并且保持锁的时间段。适合使用自旋锁。 注：该例子为非公平锁，获得锁的先后顺序，不会按照进入lock的先后顺序进行。 1.9 可中断锁可中断锁：顾名思义，就是可以相应中断的锁。在Java中，synchronized就不是可中断锁，而Lock是可中断锁。如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。lockInterruptibly()的用法体现了Lock的可中断性。 2. sychronized简介： synchronized是Java的一个关键字，它能够将代码块(方法)锁起来。synchronized是一种互斥锁，synchronized是一种内置锁/监视器锁。一次只能允许一个线程进入被锁住的代码块。Java中每个对象都有一个内置锁(监视器,也可以理解成锁标记)，而synchronized就是使用对象的内置锁(监视器)来将代码块(方法)锁定的！ 用处： synchronized保证了线程的原子性。(被保护的代码块是一次被执行的，没有任何线程会同时访问)synchronized还保证了可见性。(当执行完synchronized之后，修改后的变量对其他的线程是可见的)synchronized通过使用内置锁，来实现对变量的同步操作，进而实现了对变量操作的原子性和其他线程对变量的可见性，从而确保了并发情况下的线程安全。 2.1 实现原理 同步代码块monitorenter 指令插入到同步代码块的开始位置，monitorexit 指令插入到同步代码块的结束位置，JVM 需要保证每一个 monitorenter 都有一个 monitorexit 与之相对应。任何对象都有一个 monitor 与之相关联，当且一个 monitor 被持有之后，他将处于锁定状态。线程执行到 monitorenter 指令时，将会尝试获取对象所对应的 monitor 所有权，即尝试获取对象的锁。 同步方法方法修饰符上的ACC_SYNCHRONIZED实现。synchronized底层是是通过monitor对象，对象有自己的对象头，存储了很多信息，其中一个信息标示是被哪个线程持有。synchronized 方法会被翻译成普通的方法调用。在 JVM 字节码层面并没有任何特别的指令来实现被 synchronized 修饰的方法。在 Class 文件的方法表中将该方法的 access_flags 字段中的 synchronized 标志位置 1，表示该方法是同步方法并使用调用该方法的对象（对象锁）或该方法所属的 Class（类锁） 做为锁对象。 2.2 使用方法2.2.1 修饰普通方法获取到的锁为对象锁(即所处类的对象实例)。 123public class A{ public synchronized void test() { }} 2.2.2 修饰代码块也均为对象锁 1234567891011public class A1{ public void test() { synchronized (this){ } }//内置锁}public class A2{ private Object object = new Object(); public void test() { synchronized (object){ } }//客户端锁} 2.2.3 修饰静态方法获取到的是类锁(类的字节码文件对象) 1234public class A{ public static synchronized void test() { } //相当于synchronized(A.classs){}} 2.3 类锁与对象锁类（即class）：是虚拟机在编译期间产生的，同一个类在一个系统里面只会存在一个，它和静态变量和静态常量都存储在内存的方法区；对象：是在运行期间产生的，同一个系统可以产生（new）同一个类型的多个对象，它存储在内存的堆区中；类锁：锁是加持在类上的，用synchronized static 或者synchronized(class)方法使用的锁都是类锁，因为class和静态方法在系统中只会产生一份，所以在单系统环境中使用类锁是线程安全的；对象锁：synchronized 修饰非静态的方法和synchronized(this)都是使用的对象锁，一个系统可以有多个对象实例，所以使用对象锁不是线程安全的，除非保证一个系统该类型的对象只会创建一个（通常使用单例模式）才能保证线程安全;类锁和对象锁是不会冲突。 2.4 锁优化sychronized优化操作：适应自旋锁，锁消除，锁粗化，轻量级锁，偏向锁。 2.4.1 自旋锁与自适应锁在JDK1.6之前sychronized被称为“重量级锁”是由于互斥同步性能较大的影响了阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，用户态转入内核态是比较耗费系统性能的。自旋锁假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环，使当前线程不放弃处理器的执行时间，经过若干次循环后若得到锁，就顺利进入临界区。自旋锁虽然避免了线程切换的开销，但它占用处理器时间，若锁被占用时间较短，效果较好，反之白白占用CPU资源，带来性能上的浪费。JDK1.4.2引入自旋锁，自旋有一定的限度，超过一定次数后还没有成功获取锁，只能进行挂起。JDK1.6引入自适应自旋锁，意味着自旋的时间不再固定。 如果同一个锁对象上，自旋等待刚刚成功获取锁，并且持有锁的线程正在运行，那么虚拟机就会认为此次自旋也很有可能成功，进而它将允许自旋等待持续相对更长的时间，比如 100 个循环。如果对于某个锁，自旋很少成功获取过，那么在以后获取这个锁时将可能自动省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越精准，虚拟机也就会越来越“聪明”。 2.4.2 锁消除JVM在JIT编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，消除没有必要的锁以节省毫无意义的请求锁时间。锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。 2.4.3 锁粗化如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作出现在循环体中，即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。如果虚拟机探测到有一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展(粗化)到整个操作序列的外部。 2.4.4 轻量级锁JDK1.6中引入的一项锁优化，本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。如果没有竞争，轻量级锁使用了CAS操作避免了使用互斥量的开销，但如果存在锁竞争，除了互斥量的开销外，还额外发生了CAS操作，轻量级锁会比传统的重量级锁更慢。 2.4.5 偏向锁JDK1.6中引入的一项锁优化，目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。偏向锁在无竞争情况下把这个同步都消除掉了，连CAS操作都不做了。该锁会偏向于第一个获得它的线程，接下来的执行过程中若该锁没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步。 2.4.6 各个状态锁锁主要存在四种状态：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。他们会随着竞争的激烈而逐渐升级。锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。 锁 优点 缺点 适用场景 偏向锁 加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。 如果线程间存在锁竞争，会带来额外的锁撤销的消耗。 适用于只有一个线程访问同步块场景。 轻量级锁 竞争的线程不会阻塞，提高了程序的响应速度。 始终得不到锁的线程使用自旋会消耗CPU。 追求响应时间。同步块执行速度非常快。 重量级锁 线程竞争不使用自旋，不会消耗CPU。 线程阻塞，响应时间缓慢。 同步块执行速度较慢。 3. LOCK显式锁JDK1.5之后加入Lock显式锁，之前我们都是使用Synchronized锁来使线程安全的。Lock方式来获取锁支持中断、超时不获取、是非阻塞的。提高了语义化，哪里加锁，哪里解锁都得写出来。Lock显式锁可以给我们带来很好的灵活性，但同时我们必须手动释放锁。支持Condition条件对象。允许多个读线程同时访问共享资源。Lock锁在刚出来的时候很多性能方面都比Synchronized锁要好，但是从JDK1.6开始Synchronized锁就做了各种的优化. 3.1 Lock通过Lock源码可知，Lock为一个接口 123456789101112131415java.util.concurrent.lockspublic interface Lock { void lock(); //获取锁,若锁已被其他线程获取，则进行等待 void lockInterruptibly() throws InterruptedException; //当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。由于lockInterruptibly()的声明中抛出了异常，所以lock.lockInterruptibly()必须放在try块中或者在调用lockInterruptibly()的方法外声明抛出InterruptedException。 //注意，当一个线程获取了锁之后，是不会被interrupt()方法中断的。因为本身在前面的文章中讲过单独调用interrupt()方法不能中断正在运行过程中的线程，只能中断阻塞过程中的线程。因此当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，只有进行等待的情况下，是可以响应中断的。而用synchronized修饰的话，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。 boolean tryLock(); //表示来尝试获取锁，返回获取是否成功，无论如何都会立即返回，在拿不到锁时不会一直等待。 boolean tryLock(long time, TimeUnit unit) throws InterruptedException; //和tryLock()方法类似，这个方法在拿不到锁时会等待一定的时间，在时间期限内如果还拿不到锁，则返回false，否则返回true。 void unlock(); //释放锁，当执行lock()后必须释放锁，并且异常发生时不会自动释放锁。且需要在try{}catch{}中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生。 Condition newCondition();} 3.2 ReentrantLock可重入锁。ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法。在ReentrantLock中定义了2个静态内部类，一个是NotFairSync，一个是FairSync，分别用来实现非公平锁和公平锁。我们可以在创建ReentrantLock对象时，通过以下方式来设置锁的公平性： ReentrantLock lock = new ReentrantLock(true); 如果参数为true表示为公平锁，为fasle为非公平锁。默认情况下，如果使用无参构造器，则是非公平锁。另外在ReentrantLock类中定义了很多方法，比如： isFair() //判断锁是否是公平锁isLocked() //判断锁是否被任何线程获取了isHeldByCurrentThread() //判断锁是否被当前线程获取了hasQueuedThreads() //判断是否有线程在等待该锁 在ReentrantReadWriteLock中也有类似的方法，同样也可以设置为公平锁和非公平锁。不过要记住，ReentrantReadWriteLock并未实现Lock接口，它实现的是ReadWriteLock接口。 使用方式： 1234567891011Lock lock = new ReentrantLock();Condition condition = lock.newCondition();lock.lock();try { while(条件判断表达式) { condition.wait(); } // 处理逻辑} finally { lock.unlock();//需要显示的获取锁，并在finally块中显示的释放锁，目的是保证在获取到锁之后，最终能够被释放。} 3.3 ReadWriteLock将文件的读写操作分开，分成两个锁来分配给线程，从而使得多个线程可以同时进行读操作，提升读写操作的效率。不过要注意的是，如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。 1234public interface ReadWriteLock { Lock readLock();//获取读锁 Lock writeLock();//获取写锁} 4. Lock和sychronized总结来说，Lock和synchronized有以下几点不同： 1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。5）Lock可以提高多个线程进行读操作的效率。在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。 5. AbstractQueuedSynchronizer简称AQS，AQS的核心包括了这几方面：同步队列、独占式锁的获取和释放、共享锁的获取和释放、可中断锁，超时等待锁获取。 同步队列共享资源被某个线程占有后，其他请求该资源的线程将会阻塞而进入同步队列。在AQS中则是通过链式方式实现，AQS提供了一个内部静态类Node作为链式节点的数据结构，每个节点拥有前驱和后继节点，即双向队列，并通过头尾指针来管理同步队列，当线程获取锁失败做入队操作，当该节点获取锁成功后进行出队操作。 未完待续","link":"/2019/04/05/%E5%85%B3%E4%BA%8EJava%E9%94%81%E7%9A%84%E6%95%B4%E7%90%86/"},{"title":"第一篇测试","text":"本篇为博客测试。 正文开始欢迎来到 微困!这是我的首次博客测试附上小教程： 本博客基于Hexo生成，需要安装nodejs，默认安装npm包管理工具。打开Git Bash从npm安装Hexo: npm install hexo-cli -g 选择一个自己的文件夹作为博客根目录，在目录下打开命令行初始化博客空间，生成博客所需要的文件后安装依赖包: hexo init hexo_blogcd hexo_blognpm install 本博客主题采用ICARUS Hexo中通常有两份配置文件，一个是站点根目录下的站点配置文件（../_config.yml），另一个是主题目录下的主题配置文件（../themes/xxx/_config.yml） 生成的目录如下： – hexo_blog ├── node_modules &emsp; //NPM安裝依賴包 ├── scaffolds ├── source &emsp;└──_posts &emsp; //新建文件存放位置 ├── themes &emsp; //相關主題存放位置 ├── _config.yml &emsp; //Hexo 博客站點配置文件 ├── .gitignore ├── db.json └── package.json 可在本地预览生成效果： hexo g #完整命令为hexo generate,用于生成静态文件 hexo s #完整命令为hexo server,用于启动服务器，主要用来本地预览 写博 hexo n “my article” #完整命令为hexo new,用于新建一篇名为“my article”的文章 发布！ hexo d #完整命令为hexo deploy,用于将本地文件发布到github等git仓库上 一级标题二级标题三级标题四级标题五级标题不能再小了斜体1 或者 斜体2粗体1 或则 粗体2斜粗体使用关键字 Use the printf() function 强调文字1文字2 分隔线1 2 3 4 这是一个链接 ## 这不是二级标题(用\\表示注释) 表格用:表示对齐格式 game studio Battelfield V DICE Cyberpunk 2077 CD Projekt RED 以下为区块引用 Do not go gentle into that good nightDylan Thomas, 1914 - 1953 Do not go gentle into that good night,Old age should burn and rave at close of day;Rage, rage against the dying of the light.嵌套使用 Though wise men at their end know dark is right,Because their words had forked no lightning theyDo not go gentle into that good night.开始嵌套 Good men, the last wave by, crying how brightTheir frail deeds might have danced in a green bay,Rage, rage against the dying of the light.继续嵌套 Wild men who caught and sang the sun in flight,And learn, too late, they grieved it on its way,Do not go gentle into that good night.疯狂嵌套 Grave men, near death, who see with blinding sightBlind eyes could blaze like meteors and be gay,Rage, rage against the dying of the light.眼花 And you, my father, there on the sad height,Curse, bless, me now with your fierce tears, I pray.Do not go gentle into that good night.Rage, rage against the dying of the light. 使用脚注Here is a footnote reference,[^1] and another.[^longnote][^1]: Here is the footnote.[^longnote]: Here’s one with multiple blocks.Subsequent paragraphs are indented to show that theybelong to the previous footnote. 列表* + - 无序列表 a b c d e f g h 有序列表 a b c d 代码:12345678910using System;namespace WeiKun{ class Program { static void Main(string[] args) { } }} 区块代码using System; namespace WeiKun { class Program { static void Main(string[] args) { } }视频测试1 视频测试2 音频测试1","link":"/1996/12/31/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%B5%8B%E8%AF%95/"},{"title":"开发系统弹框应用随记","text":"这是一篇没什么用的菜鸟文章。 系统应用系统签名分四种类型：testkey,platform,media,sharedplatform需要apk所在进程的uid为system，则在manifest根节点加入 android:sharedUserId=”android.uid.system”其签名文件位于Android源码目录build/target/product/security中：platform.pk8，platform.x509.pem使用Android自带的签名工具signapk.jar,该文件位于源码目录out/host/linux-x86/framework/下。将以上三个文件置于同一目录下，执行命令 1java -jar signapk.jar platform.x509.pem platform.pk8 old.apk new.apk 即可生成带系统签名的apk (jdk版本需为1.8) Android P(28)上的静默安装首先需要在Manifest添加。常规的显式安装： 123456intent = new Intent(Intent.ACTION_VIEW);intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);intent.setDataAndType( FileProvider.getUriForFile(MainActivity.this,BuildConfig.APPLICATION_ID+\".provider\" ,file), \"application/vnd.android.package-archive\");startActivity(intent); 静默安装：在Android N(24)之前: 12345Intent intent;intent = new Intent(\"android.intent.action.VIEW.HIDE\");intent.setDataAndType(Uri.fromFile(file), \"application/vnd.android.package-archive\");intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);startActivity(intent); PM命令在Android P上已失效，转而采用文件流的方式来进行安装（比较麻烦）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public static void install(Context context,File apkFile) { PackageInstaller packageInstaller = context.getPackageManager().getPackageInstaller(); PackageInstaller.SessionParams sessionParams = new PackageInstaller.SessionParams(PackageInstaller .SessionParams.MODE_FULL_INSTALL); sessionParams.setSize(apkFile.length()); int sessionId = createSession(packageInstaller, sessionParams); if (sessionId != -1) { boolean copySuccess = copyInstallFile(packageInstaller, sessionId, apkFile); if (copySuccess) { execInstallCommand(context,packageInstaller, sessionId)); } }}private static int createSession(PackageInstaller packageInstaller, PackageInstaller.SessionParams sessionParams) { int sessionId = -1; try { sessionId = packageInstaller.createSession(sessionParams); } catch (IOException e) { e.printStackTrace(); } return sessionId;}private static boolean copyInstallFile(PackageInstaller packageInstaller, int sessionId, File apkFile) { InputStream in = null; OutputStream out = null; PackageInstaller.Session session = null; boolean success = false; try { session = packageInstaller.openSession(sessionId); out = session.openWrite(\"base.apk\", 0, apkFile.length()); in = new FileInputStream(apkFile); int total = 0, c; byte[] buffer = new byte[65536]; while ((c = in.read(buffer)) != -1) { total += c; out.write(buffer, 0, c); } session.fsync(out); Log.i(TAG, \"streamed \" + total + \" bytes\"); success = true; } catch (IOException e) { e.printStackTrace(); } finally { IOUtils.closeQuietly(out); IOUtils.closeQuietly(in); IOUtils.closeQuietly(session); } return success;}private static void execInstallCommand(Context context,PackageInstaller packageInstaller, int sessionId) { PackageInstaller.Session session = null; try { session = packageInstaller.openSession(sessionId); Intent intent = new Intent(context, InstallResultReceiver.class); PendingIntent pendingIntent = PendingIntent.getBroadcast(context, 1, intent, PendingIntent.FLAG_UPDATE_CURRENT); session.commit(pendingIntent.getIntentSender()); } catch (IOException e) { e.printStackTrace(); } finally { IOUtils.closeQuietly(session); }} 安装回调（广播接收）: 123456789101112131415 public class InstallResultReceiver extends BroadcastReceiver { private static final String TAG = InstallResultReceiver.class.getSimpleName(); @Override public void onReceive(Context context, Intent intent) { if (intent != null) { final int status = intent.getIntExtra(PackageInstaller.EXTRA_STATUS, PackageInstaller.STATUS_FAILURE); if (status == PackageInstaller.STATUS_SUCCESS) { //安装成功 } else { //安装失败 } } }} 屏蔽状态栏下拉StatusBarManager类及其方法被标记为@Hide，需要通过反射方法来实现。 12345678910111213141516171819/** * 禁止/恢复 状态栏下拉 * @param mContext 应用上下文 * @param disable 是否禁止 禁止 0x00010000 恢复 0x00000000 * */ public static void disableStatusBar(Context mContext,boolean disable) { try { Object service = mContext.getSystemService(\"statusbar\"); Class&lt;?&gt; clz = getClass(\"android.app.StatusBarManager\"); if (clz!=null){ Method method = clz.getMethod(\"disable\", int.class); method.invoke(service, disable ? 0x00010000 : 0x00000000); } } catch (Exception e) { e.printStackTrace(); } } 其他类似需要反射的系统类如 android.os.SystemProperties,通过getMethod获取get和set方法来获取设置系统属性。 禁止导航栏屏蔽导航按键： 1234567891011121314151617181920/** * HOME键屏蔽位 */public static final int FLAG_HOMEKSY_DISPATCHED = 0x80000000;/** * 屏蔽任务键 */public static final int STATUS_BAR_DISABLE_RECENT = 0x01000000;/** * 屏蔽导航按键 */private void disableNavigationBar() { if (dialog.getWindow() != null) { dialog.getWindow().setFlags(FLAG_HOMEKSY_DISPATCHED, FLAG_HOMEKSY_DISPATCHED); dialog.getWindow().setFlags(STATUS_BAR_DISABLE_RECENT, STATUS_BAR_DISABLE_RECENT); dialog.getWindow().addFlags(3); dialog.getWindow().addFlags(5); }} 隐藏底部导航: 1234567891011121314151617181920212223/** * 显示/隐藏 底部导航 */ private void setNavigationBarVisibility(boolean visible) { View decorView; if (dialog.getWindow() != null) { decorView = dialog.getWindow().getDecorView(); } else { return; } if (!visible) { int uiOptions = View.SYSTEM_UI_FLAG_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY | View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN; decorView.setSystemUiVisibility(uiOptions); } else { int uiOptions = View.SYSTEM_UI_FLAG_VISIBLE; decorView.setSystemUiVisibility(uiOptions); } }","link":"/2019/12/23/%E5%BC%80%E5%8F%91%E7%B3%BB%E7%BB%9F%E5%BC%B9%E6%A1%86%E5%BA%94%E7%94%A8%E9%9A%8F%E8%AE%B0/"},{"title":"JNI中的内存泄漏","text":"阐述一些JNI开发中常遇到的内存泄漏相关问题。 1.Java内存相关概述Java内存空间可划分为Heap Memory和Native Memory，前者供Java的应用程序所使用，后者供JVM自身进程使用。 1.1 Java HeapJava堆是Java虚拟机内存中最大的一块，所有线程共享着这一块区域，几乎所有对象都在这里分配内存。Java对象存储在Java Heap中，也是垃圾收集的主要区域(GC堆)。堆不需要连续的内存，并且可以动态增加，这块内存在运行时会不断扩充，当扩充到容量上限，在GC后还是没有足够的空间来分配给新的对象,将抛出OOM(Out of Memory)异常,导致JVM进程崩溃。通常我们通过以下命令来指定程序的堆内存大小: 123java -Xmx1024m -Xms1024m//-Xmx1024m 设置JVM最大可用内存为1024M//-Xms1024m 设置JVM初始内存为1024M Android对于每个应用都有内存限制，其配置位于/system/build.prop文件中。可在应用的manifest文件中的application节点加入以下代码让Dalvik/ART虚拟机分配更大的堆内存空间： 1android:largeHeap=&quot;true&quot; 1.2 C-HeapJVM 进程空间中，Java Heap 以外的内存空间称为 JVM 的Native Memory，也称为C-Heap，这块内存的作用有：1.JVM进程的很多资源都是存储在native memory 中，例如载入的代码映像，类加载器和类信息、线程的堆栈，线程的管理控制块，JVM的静态数据、全局数据等等；2.包括 JNI 程序中 Native Code 分配到的资源；3.JIT（即时编译器）编译时使用Native Memory，并且JIT的输入（Java字节码）和输出（可执行代码）也都是保存在Native Memory；4.管理Java Heap的状态数据，用于GC；5.NIO direct buffer；JNI 程序开发者要遵循 native 语言本身的内存管理机制，避免造成内存泄漏。以 C 语言为例，当用 malloc() 在进程堆中动态分配内存时，JNI 程序在使用完后，应当调用 free() 将内存释放。 2. JNI引用类型和可能造成的内存泄漏2.1 本地引用Local ReferenceJNI提供以下方法来创建和删除Local Reference: 12NewLocalRef()DeleteLocalRef() 有时候在native方法中创建了大量v的JNI Local Reference，可能造成native memory的内存泄漏，在方法返回到JVM 前把分配得到的native memory用尽则导致native memory的OOM(out of memory)。如下代码： 1234jint = 0;for(; i&lt;count; i++) str = (*env)-&gt;NewStringUTF(env, \"0\"); } 代码中不断从Java Heap中创建String对象，然后传给native memory的Local Reference，最后将创建过多的Local Reference，导致JNI内部的JNI Local Reference 表内存溢出。而Local Reference的生命周期处于native方法的执行期内，当线程切换到java环境时则所有JNI Local Reference被删除，生命周期结束，除此之外可调用相关JNI函数(DeleteLocalRef())来提前结束周期，释放资源。其内容无法直接访问，必须通过JNI函数来间接访问。当线程从Java环境切换至native环境时，JVM会分配一块内存，并创建一个Local Reference表，每当native方法引用到一个Java对象时，就会在表中创建一个Local Reference。当调用DeleteLocalRef()后，将该引用从表中删除，并且失效。由此可见Local Reference是对Java的对象的引用，native中的Local Ref表存储引用的映射，Local Ref表所分配到的内存往往较小，当表空间被用光，JVM会抛出异常。所以，及时调用DeleteLocalRef()，正确的控制Local Reference的生命周期，可以有效避免潜在的内存泄漏。 2.2 全局引用全局引用分为强引用和弱引用，即Global Reference和Weak Global Reference。观察Android P的源码art/runtime/java_vm_ext.cc，可看出JavaVMExt初始化(构造函数)的时候全局引用的容量上限是不允许扩容的，其容量上限均为51200: 12static constexpr size_t kGlobalsMax = 51200;static constexpr size_t kWeakGlobalsMax = 51200; 而Local Reference Table的上限为512： 1kLocalsInitial = 512; 2.2.1 Global ReferenceJNI提供以下方法来创建和删除Global Reference: 12NewGlobalRef()DeleteGlobalRef() Global Reference管理不当也会导致 Java Heap 的内存泄漏。Global Reference具有全局性，可以在多个Native Method调用过程和多线程中使用，在主动释放之前，它是一直有效的（GC不会回收其内存），若未及时删除它引用的Java对象，该对象将永远停留在Java Heap中，将可能导致内存泄漏。在使用过程中创建和删除一定要成对出现，否则可能导致global reference overflow。 2.2.2 Weak Global ReferenceJNI提供以下方法来创建和删除Weak Global Reference: 12NewWeakGlobalRef() DeleteWeakGlobalRef() 既然是弱引用，它与Global Reference的区别就是随时可能被GC收走。我们可以通过isSameObject()与NULL进行比较，如果返回JNI_TRUE，则表示该引用已经被回收。 3. JNI中的资源释放基本类型不需要手动释放需要手动释放有（引用类型，数组家族），如jstring，jobject ，jobjectArray，jintArray ，jclass ，jmethodID等。jobject，jobjectArray，jclass ，jmethodID等引用类型释放方法： 1(*jniEnv)-&gt;DeleteLocalRef(jniEnv, XXX); 例如jstring转char数组后需要进行释放操作： 1234jstring jstr = (*jniEnv)-&gt;CallObjectMethod(jniEnv, mPerson, getName);char* cstr = (char*) (*jniEnv)-&gt;GetStringUTFChars(jniEnv,jstr, 0);(*jniEnv)-&gt;ReleaseStringUTFChars(jniEnv, jstr, cstr);(*jniEnv)-&gt;DeleteLocalRef(jniEnv, jstr); 数组家族调用ReleaseArrayElements()来释放资源，例如ByteArray转char数组，并在最后释放资源： 12345678jint len = (*env)-&gt;GetArrayLength(env,byteArray);char *result = (char *) malloc(len* sizeof(char));jbyte *bytes = (*env)-&gt;GetByteArrayElements(env,byteArray,JNI_FALSE);memset(result, 0, size);memcpy(result, bytes, size);result[size] = 0;//释放资源(*env)-&gt;ReleaseByteArrayElements(env, byteArray, bytes, JNI_FALSE); 本地引用示例 12jbyteArray newArray = (*env)-&gt;NewByteArray(env,size);(*env)-&gt;DeleteLocalRef(env,newArray); 全局引用示例: 12jobject ref= env-&gt;NewGlobalRef(customObj);env-&gt;DeleteGlobalRef(customObj);","link":"/2020/04/02/JNI%20memory%20leak/"}],"tags":[{"name":"技术","slug":"技术","link":"/tags/%E6%8A%80%E6%9C%AF/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"蓝牙","slug":"蓝牙","link":"/tags/%E8%93%9D%E7%89%99/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Netty","slug":"Netty","link":"/tags/Netty/"},{"name":"JNI","slug":"JNI","link":"/tags/JNI/"}],"categories":[{"name":"技术","slug":"技术","link":"/categories/%E6%8A%80%E6%9C%AF/"}]}